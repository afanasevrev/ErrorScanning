package com.example.ErrorScanning.vulnerabilityscan;

import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

@Service
public class VulnerabilityScannerService {
    private final RestTemplate restTemplate = new RestTemplate();
    /**
     * Проверка на XSS:
     * Отправляем GET-запрос с параметром, содержащим XSS payload, и анализируем, вернулся ли payload в ответе.
     */
    public VulnerabilityScanResult scanForXSS(String targetUrl) {
        String xssPayload = "<script>alert('XSS')</script>";
        try {
            // Предполагаем, что приложение ожидает параметр "input"
            String encodedPayload = URLEncoder.encode(xssPayload, StandardCharsets.UTF_8.toString());
            String fullUrl = targetUrl + "?input=" + encodedPayload;

            ResponseEntity<String> response = restTemplate.getForEntity(fullUrl, String.class);
            boolean vulnerable = response.getBody() != null && response.getBody().contains(xssPayload);

            String details = vulnerable
                    ? "XSS payload найден во входных данных – возможно уязвимость XSS."
                    : "Ответ не содержит неэкранированного XSS payload.";
            return new VulnerabilityScanResult("XSS", vulnerable, details);
        } catch (Exception e) {
            return new VulnerabilityScanResult("XSS", false, "Ошибка сканирования: " + e.getMessage());
        }
    }
    /**
     * Проверка на CSRF:
     * Отправляем POST запрос без CSRF токена и анализируем ответ.
     * Реальная проверка зависит от логики работы целевого приложения.
     */
    public VulnerabilityScanResult scanForCSRF(String targetUrl) {
        try {
            // Предполагаем, что тестируемый endpoint принимает параметры в формате form-url-encoded
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            // Формируем тело запроса без CSRF токена
            String body = "param1=value1&param2=value2";
            HttpEntity<String> requestEntity = new HttpEntity<>(body, headers);

            ResponseEntity<String> response = restTemplate.postForEntity(targetUrl, requestEntity, String.class);

            // Простой анализ: если POST запрос выполняется успешно без ошибок от CSRF защиты,
            // это может указывать на отсутствие защиты.
            boolean vulnerable = response.getStatusCode().is2xxSuccessful() &&
                    (response.getBody() == null || !response.getBody().contains("CSRF"));
            String details = vulnerable
                    ? "Запрос выполнен без проверки CSRF – защита может отсутствовать."
                    : "Ответ содержит возможные указания на защиту CSRF.";
            return new VulnerabilityScanResult("CSRF", vulnerable, details);
        } catch (Exception e) {
            return new VulnerabilityScanResult("CSRF", false, "Ошибка сканирования: " + e.getMessage());
        }
    }
    /**
     * Проверка на XXE:
     * Отправляем POST запрос с XML, содержащим XXE payload, и анализируем ответ.
     */
    public VulnerabilityScanResult scanForXXE(String targetUrl) {
        // Пример payload – попытаемся прочитать системный файл.
        String xxePayload = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n"
                + "<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>\n"
                + "<foo>&xxe;</foo>";
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_XML);
            HttpEntity<String> requestEntity = new HttpEntity<>(xxePayload, headers);

            ResponseEntity<String> response = restTemplate.postForEntity(targetUrl, requestEntity, String.class);

            // Если ответ содержит типичные для /etc/passwd строки (например "root:"), уязвимость может быть обнаружена.
            boolean vulnerable = response.getBody() != null && response.getBody().contains("root:");
            String details = vulnerable
                    ? "XXE payload обработан – возможно уязвимость XXE."
                    : "XXE payload не обнаружен в ответе.";
            return new VulnerabilityScanResult("XXE", vulnerable, details);
        } catch (Exception e) {
            return new VulnerabilityScanResult("XXE", false, "Ошибка сканирования: " + e.getMessage());
        }
    }
}
